# Answer Guide
| Problem | Solution |
| --- | --- |
| 15. Given int array, implement `threeSum(nums)` to return all triplets that sum up to 0, no duplicate triplets and no reusing elements | <li>Solution: sort array then use two-pointer high & low approach to "walk" towards the middle so that the sum is 0. Save valid triplets and update the high & low pointers and the index so that we skip duplicates. O(n^2) time, O(log(n)) space (sort). |
| 49. Given string array, implement `groupAnagrams(strs)` which merges the anagrams together and returns it as an array | <li>Solution: implement a hashing algorithm based on letter counts, so anagrams will return the same hash. Iterate through strings, get their hash and add them to their anagram group, stored in a dictionary. Return the dictionary's values. O(nk) time where n is the number of strings, k is the length of the longest string, O(nk) space to store the dictionary. |
| 53. Given int array, implement `maxSubArray(nums)` to get the largest sum from a contiguous subarray in `nums` | <li>Solution: keep track of the maximum so far and the current sum. Whenever the sum is negative, reset the sum (starting new subarray). O(n) time, O(1) space. |
| 56. Given array of intervals in the form `[start, stop]`, implement `merge(intervals)` to merge all the overlapping intervals and return an array of the non-overlapping intervals. | <li>Solution: sort the intervals by start time and loop through them. An interval will either extend the current interval (update current stop) or be the start of a new interval. Push results into an array or use two pointers to mutate the intervals in place. O(nlog(n)) time, O(log(n)) space. |
| 88. Given sorted int arrays, merge them together as one sorted array | <li>Naive: merge then sort. O((n+m)log(n+m)) time, O(n) space.<li>Optimal: two pointer approach to write values in sorted order. O(n+m) time, O(n+m) space.<li>Optimal 2: two pointer approach to write values in reverse sorted order from back to front in `nums1` (it was given it had enough space). O(n+m) time, O(1) space. |
| 100. Given roots of two binary trees, implement `isSameTree(p, q)` to check if they are equal in shape | <li>Compare the current nodes, then recursively compare the nodes' left and right children. O(n) time, O(log(n)) space. |
| 121. Given int array representing stock prices, implement `maxProfit(prices)` to get the maximum possible profit | <li>Naive: test each possible combination of start and stop indices while keeping track of max profit. O(n^2) time, O(1) space.<li>Optimal: along with keeping track of max profit, keep track of minimum price so far so we can calculate profits in one pass. O(n) time, O(1) space. |
| 152. Given int array, implement `maxProduct(nums)` to find the contiguous subarray with the largest product and return that product | <li>Solution: initialize `ans`, `maxSoFar`, and `minSoFar` to the first element. Loop through the remaining elements and update `maxSoFar` and `minSoFar` so they are the biggest positive and negative numbers possible. Update `ans` whenever `maxSoFar` is bigger than it. O(n) time, O(1) space. |
| 217. Given int array, implement `containsDuplicate(nums)` to detect if any number appears at least twice | <li>Solution: use a set to keep track of numbers seen so far. O(n) time, O(n) space. |
| 238. Given an int array, implement `productExceptSelf(nums)` that returns an array `answer` where `answer[i]` equals the product of all the elements in `nums` except `nums[i]` | <li>Solution: create array `rProd` where `rProd[i]` is the product of all the elements to the right of `nums[i]`. Either do the same for the left side, or accumulate the product in a variable. Then `answer[i] = lProd[i] * rProd[i]`. O(n) time, O(n) space. |
| 242. Given two strings, implement `isAnagram(s, t)` that returns if the strings are valid anagrams | <li>Solution: count occurrences of each letter for each string using a fixed array or dictionary, then compare the counts. O(n) time where n is the length of the strings, O(k) space where k is the size of the character set. |
| 303. Given int array, implement `rangeSum(left, right)` to get sum between indices, inclusive | <li>Naive: iterate from `left` to `right`. O(n) time, O(1) space.<li>Optimal: use a cumulative sum array: `csum(right) - csum(left)`. O(n) preprocessing time, O(1) time, O(n) space. |
| 304. Given 2d int array, implement `sumRegion(row1, col1, row2, col2)` to get sum of the matrix region | <li>Naive: nested loop to iterate through region. O(mn) time, O(1) space.<li>Optimal: use cumulative sum array: `csum(row2, col2) - csum(row1-1, col2) - csum(row2, col1-1) + csum(row1-1, col1-1)`. O(mn) preprocessing time, O(1) time, O(mn) space. |
| 307. Given int array, implement `sumRange(left, right)` to get sum between indices, inclusive, and `update(index, val)` to update the value at an index | <li>Naive: iterate from `left` to `right` to get sum, update in place. O(n) sum time, O(1) update time, O(1) space.<li>Optimal: sqrt decomposition to split array into blocks, then sum over the blocks plus elements outside the blocks. O(n) preprocessing time, O(√n) space, O(√n) sum time, O(1) update time.<li>Optimal 2: use a segment tree, update by applying diff upwards, sum using left and right pointers that move upwards and inwards until they meet. O(n) preprocessing time, O(n) space, O(log(n)) sum time, O(log(n)) update time. |
| 347. Given int array and int k, implement `topKFrequent(nums, k)` to return the top k frequent elements in any order | <li>Naive: count using hashmap, then sort. O(nlog(n)) time, O(n) space.<li>Optimal: count using hashmap, store counts and their nums in buckets, read off top buckets until k nums are read. O(n) time, O(n) space. |
