# Answer Guide
| Problem | Solution |
| --- | --- |
| 53. Given int array, implement `maxSubArray(nums)` to get the largest sum from a contiguous subarray in `nums` | <li>Solution: keep track of the maximum so far and the current sum. Whenever the sum is negative, reset the sum (starting new subarray). O(n) time, O(1) space. |
| 88. Given sorted int arrays, merge them together as one sorted array | <li>Naive: merge then sort. O((n+m)log(n+m)) time, O(n) space.<li>Optimal: two pointer approach to write values in sorted order. O(n+m) time, O(n+m) space.<li>Optimal 2: two pointer approach to write values in reverse sorted order from back to front in `nums1` (it was given it had enough space). O(n+m) time, O(1) space. |
| 100. Given roots of two binary trees, implement `isSameTree(p, q)` to check if they are equal in shape | <li>Compare the current nodes, then recursively compare the nodes' left and right children. O(n) time, O(log(n)) space. |
| 121. Given int array representing stock prices, implement `maxProfit(prices)` to get the maximum possible profit | <li>Naive: test each possible combination of start and stop indices while keeping track of max profit. O(n^2) time, O(1) space.<li>Optimal: along with keeping track of max profit, keep track of minimum price so far so we can calculate profits in one pass. O(n) time, O(1) space.
| 217. Given int array, implement `containsDuplicate(nums)` to detect if any number appears at least twice | <li>Solution: use a set to keep track of numbers seen so far. O(n) time, O(n) space. |
| 238. Given an int array, implement `productExceptSelf(nums)` that returns an array `answer` where `answer[i]` equals the product of all the elements in `nums` except `nums[i]` | <li>Solution: create array `rProd` where `rProd[i]` is the product of all the elements to the right of `nums[i]`. Either do the same for the left side, or accumulate the product in a variable. Then `answer[i] = lProd[i] * rProd[i]`. O(n) time, O(n) space. |
| 242. Given two strings, implement `isAnagram(s, t)` that returns if the strings are valid anagrams | <li>Solution: count occurrences of each letter for each string using a fixed array or dictionary, then compare the counts. O(n) time where n is the length of the strings, O(k) space where k is the size of the character set. |
| 303. Given int array, implement `rangeSum(left, right)` to get sum between indices, inclusive | <li>Naive: iterate from `left` to `right`. O(n) time, O(1) space.<li>Optimal: use a cumulative sum array: `csum(right) - csum(left)`. O(n) preprocessing time, O(1) time, O(n) space. |
| 304. Given 2d int array, implement `sumRegion(row1, col1, row2, col2)` to get sum of the matrix region | <li>Naive: nested loop to iterate through region. O(mn) time, O(1) space.<li>Optimal: use cumulative sum array: `csum(row2, col2) - csum(row1-1, col2) - csum(row2, col1-1) + csum(row1-1, col1-1)`. O(mn) preprocessing time, O(1) time, O(mn) space. |
| 307. Given int array, implement `sumRange(left, right)` to get sum between indices, inclusive, and `update(index, val)` to update the value at an index | <li>Naive: iterate from `left` to `right` to get sum, update in place. O(n) sum time, O(1) update time, O(1) space.<li>Optimal: sqrt decomposition to split array into blocks, then sum over the blocks plus elements outside the blocks. O(n) preprocessing time, O(√n) space, O(√n) sum time, O(1) update time.<li>Optimal 2: use a segment tree, update by applying diff upwards, sum using left and right pointers that move upwards and inwards until they meet. O(n) preprocessing time, O(n) space, O(log(n)) sum time, O(log(n)) update time. |
| 347. Given int array and int k, implement `topKFrequent(nums, k)` to return the top k frequent elements in any order | <li>Naive: count using hashmap, then sort. O(nlog(n)) time, O(n) space.<li>Optimal: count using hashmap, store counts and their nums in buckets, read off top buckets until k nums are read. O(n) time, O(n) space. |
